{
  "version": 3,
  "sources": ["../gltf-loader-ts/lib/webpack:/webpack/bootstrap", "../gltf-loader-ts/lib/webpack:/loadingmanager.ts", "../gltf-loader-ts/lib/webpack:/gltf-asset.ts", "../gltf-loader-ts/lib/webpack:/loaderutils.ts", "../gltf-loader-ts/lib/webpack:/fileloader.ts", "../gltf-loader-ts/lib/webpack:/glb-decoder.ts", "../gltf-loader-ts/lib/webpack:/gltf-loader.ts", "dep:gltf-loader-ts"],
  "sourcesContent": [" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n", "// Adapted from THREE.LoadingManager\n// https://raw.githubusercontent.com/mrdoob/three.js/master/src/loaders/LoadingManager.js\n\nexport type OnStartOnProgressCallback = ((url: string, itemsLoaded: number, itemsTotal: number) => void) | undefined;\n\nexport class LoadingManager {\n    /** URL modifier function for special I/O cases like GLB and `File` (drag-and-drop) */\n    urlModifier: ((url: string) => string) | undefined = undefined;\n    onStart: OnStartOnProgressCallback = undefined;\n    onProgress: OnStartOnProgressCallback = undefined;\n    onLoad: (() => void) | undefined = undefined;\n    onError: ((url: string) => void) | undefined = undefined;\n\n    private isLoading = false;\n    private itemsLoaded = 0;\n    private itemsTotal = 0;\n\n    itemStart(url: string) {\n        this.itemsTotal++;\n        if (!this.isLoading && this.onStart) {\n            this.onStart(url, this.itemsLoaded, this.itemsTotal);\n        }\n        this.isLoading = true;\n    }\n\n    itemEnd(url: string) {\n        this.itemsLoaded++;\n        if (this.onProgress) {\n            this.onProgress(url, this.itemsLoaded, this.itemsTotal);\n        }\n        if (this.itemsLoaded === this.itemsTotal) {\n            this.isLoading = false;\n            if (this.onLoad) {\n                this.onLoad();\n            }\n        }\n    }\n\n    itemError(url: string) {\n        if (this.onError) {\n            this.onError(url);\n        }\n    }\n\n    resolveURL(url: string) {\n        if (this.urlModifier) {\n            return this.urlModifier(url);\n        }\n        return url;\n    }\n}\n", "import { FileLoader } from './fileloader';\nimport { GLTFBinaryData } from './glb-decoder';\nimport { GlTf, GlTfId } from './gltf';\nimport { LoadingManager } from './loadingmanager';\n\n/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */\nexport const GLTF_COMPONENT_TYPE_ARRAYS: { [index: number]: any } = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n};\n\n/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */\nexport const GLTF_ELEMENTS_PER_TYPE: { [index: string]: number } = {\n    SCALAR: 1,\n    VEC2:   2,\n    VEC3:   3,\n    VEC4:   4,\n    MAT2:   4,\n    MAT3:   9,\n    MAT4:  16,\n};\n\nexport class GltfAsset {\n    /** The JSON part of the asset. */\n    gltf: GlTf;\n    glbData: GLTFBinaryData | undefined;\n    /** Helper for accessing buffer data */\n    bufferData: BufferData;\n    /** Helper for accessing image data */\n    imageData: ImageData;\n\n    constructor(gltf: GlTf, baseUri: string, glbData: GLTFBinaryData | undefined,\n        manager: LoadingManager = new LoadingManager()) {\n\n        this.gltf = gltf;\n        this.glbData = glbData;\n        this.bufferData = new BufferData(this, baseUri, manager);\n        this.imageData = new ImageData(this, baseUri, manager);\n    }\n\n    /**\n     * Fetch the data for a buffer view. Pass in the `bufferView` property of an\n     * `Accessor`.\n     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.\n     */\n    async bufferViewData(index: GlTfId): Promise<Uint8Array> {\n        if (!this.gltf.bufferViews) {\n            /* istanbul ignore next */\n            throw new Error('No buffer views found.');\n        }\n        const bufferView = this.gltf.bufferViews[index];\n        const bufferData = await this.bufferData.get(bufferView.buffer);\n        const byteLength = bufferView.byteLength || 0;\n        const byteOffset = bufferView.byteOffset || 0;\n\n        // For GLB files, the 'base buffer' is the whole GLB file, including the json part.\n        // Therefore we have to consider bufferData's offset within its buffer it as well.\n        // For non-GLB files it will be 0.\n        const baseBuffer = bufferData.buffer;\n        const baseBufferByteOffset = bufferData.byteOffset;\n\n        return new Uint8Array(baseBuffer, baseBufferByteOffset + byteOffset, byteLength);\n    }\n\n    /**\n     * Fetch the data associated with the accessor. Equivalent to `bufferViewData` for most accessors; special cases:\n     * - `accessor.bufferView` is undefined: create a buffer initialized with zeroes.\n     * - `accessor.sparse` is defined: Copy underlying buffer view and apply values from `sparse`.\n     */\n    async accessorData(index: GlTfId): Promise<Uint8Array> {\n        if (!this.gltf.accessors) {\n            /* istanbul ignore next */\n            throw new Error('No accessors views found.');\n        }\n        const acc = this.gltf.accessors[index];\n        const elementsPerType = GLTF_ELEMENTS_PER_TYPE[acc.type];\n        let data;\n        if (acc.bufferView !== undefined) {\n            data = await this.bufferViewData(acc.bufferView);\n        } else {\n            const byteSize = GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType].BYTES_PER_ELEMENT *\n                elementsPerType *\n                acc.count;\n            data = new Uint8Array(byteSize);\n        }\n\n        if (acc.sparse) {\n            // parse sparse data\n            const {count, indices, values} = acc.sparse;\n            let typedArray = GLTF_COMPONENT_TYPE_ARRAYS[indices.componentType];\n            let bufferViewData = await this.bufferViewData(indices.bufferView);\n            const indexData = new typedArray(bufferViewData.buffer,\n                bufferViewData.byteOffset + (indices.byteOffset || 0), count);\n\n            typedArray = GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType];\n            bufferViewData = await this.bufferViewData(values.bufferView);\n            const valueData = new typedArray((await this.bufferViewData(values.bufferView)).buffer,\n                bufferViewData.byteOffset + (values.byteOffset || 0), count * elementsPerType);\n\n            // copy base data and change it\n            if (acc.bufferView) { // no copy necessary if no bufferView since data was created above\n                data = new Uint8Array(data);\n            }\n\n            const typedData = new GLTF_COMPONENT_TYPE_ARRAYS[acc.componentType](data.buffer);\n            for (let i = 0; i < count; i++) {\n                for (let j = 0; j < elementsPerType; j++) {\n                    typedData[elementsPerType * indexData[i] + j] = valueData[elementsPerType * i + j];\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /** Pre-fetches all buffer and image data. Useful to avoid stalls due to lazy loading. */\n    async preFetchAll(): Promise<void[][]> {\n        return Promise.all([\n            this.bufferData.preFetchAll(),\n            this.imageData.preFetchAll(),\n        ]);\n    }\n}\n\n// tslint:disable:max-classes-per-file\nexport class BufferData {\n    asset: GltfAsset;\n    baseUri: string;\n    manager: LoadingManager;\n    loader: FileLoader;\n\n    private bufferCache: Array<Uint8Array> = [];\n\n    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager) {\n        this.asset = asset;\n        this.baseUri = baseUri;\n        this.manager = manager;\n        this.loader = new FileLoader(manager);\n        this.loader.responseType = 'arraybuffer';\n    }\n\n    /**\n     * Get the buffer data. Triggers a network request if this buffer resides\n     * in an external .bin file and is accessed for the first time (cached afterwards).\n     * when it's accessed for the first time and `preFetchAll` has not been used.\n     * To avoid any delays, use `preFetchAll` to pre-fetch everything.\n     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.\n     */\n    async get(index: GlTfId): Promise<Uint8Array> {\n        if (this.bufferCache[index] !== undefined) {\n            return this.bufferCache[index];\n        }\n\n        const gltf = this.asset.gltf;\n        if (!gltf.buffers) {\n            /* istanbul ignore next */\n            throw new Error('No buffers found.');\n        }\n        const buffer = gltf.buffers[index];\n        // If present, GLB container is required to be the first buffer.\n        if (buffer.uri === undefined) {\n            /* istanbul ignore next */\n            if (index !== 0) { throw new Error('GLB container is required to be the first buffer'); }\n            if (this.asset.glbData === undefined) {\n                throw new Error('invalid gltf: buffer has no uri nor is there a GLB buffer');\n            }\n            return this.asset.glbData.binaryChunk;\n        }\n\n        const url = resolveURL(buffer.uri, this.baseUri);\n        const bufferData: ArrayBuffer = await this.loader.load(url);\n        const bufferDataView = new Uint8Array(bufferData);\n        this.bufferCache[index] = bufferDataView;\n        return bufferDataView;\n    }\n\n    /** Pre-fetches all buffer data. */\n    async preFetchAll(): Promise<void[]> {\n        const buffers = this.asset.gltf.buffers;\n        if (!buffers) { return []; }\n        return Promise.all(buffers.map((_, i): any => this.get(i))) as Promise<void[]>;\n    }\n}\n\nexport class ImageData {\n    asset: GltfAsset;\n    baseUri: string;\n    manager: LoadingManager;\n    /** crossorigin value for file and image requests */\n    crossOrigin = 'anonymous';\n\n    private imageCache: Array<HTMLImageElement> = [];\n\n    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager) {\n        this.asset = asset;\n        this.baseUri = baseUri;\n        this.manager = manager;\n    }\n\n    /**\n     * Get the image data. Triggers a network request if image is in an external file\n     * and is accessed for the first time (cached afterwards). To avoid any delays,\n     * use `preFetchAll` to pre-fetch everything.\n     */\n    async get(index: GlTfId): Promise<HTMLImageElement> {\n        if (this.imageCache[index] !== undefined) {\n            return this.imageCache[index];\n        }\n\n        const gltf = this.asset.gltf;\n        if (!gltf.images) {\n            /* istanbul ignore next */\n            throw new Error('No images found.');\n        }\n        const image = gltf.images[index];\n\n        let sourceURI: string;\n        let isObjectURL = false;\n        if (image.bufferView !== undefined) {\n            // Load binary image data from bufferView, if provided.\n            const bufferView = await this.asset.bufferViewData(image.bufferView);\n            isObjectURL = true;\n            const blob = new Blob([bufferView], { type: image.mimeType });\n            sourceURI = URL.createObjectURL(blob);\n        } else if (image.uri !== undefined ) {\n            sourceURI = this.manager.resolveURL(resolveURL(image.uri, this.baseUri));\n        } else {\n            /* istanbul ignore next */\n            throw new Error('Invalid glTF: image must either have a `uri` or a `bufferView`');\n        }\n\n        const img = new Image();\n        img.crossOrigin = this.crossOrigin;\n\n        const promise: Promise<HTMLImageElement> = new Promise((resolve, reject) => {\n            img.onerror = () => {\n                reject(`Failed to load ${sourceURI}`);\n                this.manager.itemEnd(sourceURI);\n                this.manager.itemError(sourceURI);\n            };\n            img.onload = () => {\n                if (isObjectURL) {\n                    URL.revokeObjectURL(sourceURI);\n                }\n                this.imageCache[index] = img;\n                resolve(img);\n                this.manager.itemEnd(sourceURI);\n            };\n            // TODO!: onprogress?\n            img.src = sourceURI;\n            this.manager.itemStart(sourceURI);\n        });\n\n        return promise;\n    }\n\n    /** Pre-fetches all image data. */\n    async preFetchAll(): Promise<void[]> {\n        const images = this.asset.gltf.images;\n        if (!images) { return []; }\n        return Promise.all(images.map((_, i): any => this.get(i))) as Promise<void[]>;\n    }\n}\n\n// TODO!!: function required in this form?\nexport function resolveURL(url: string, path: string) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') { return ''; }\n    // Absolute URL http://,https://,//\n    if (/^(https?:)?\\/\\//i.test(url)) { return url; }\n    // Data URI\n    if (/^data:.*,.*$/i.test(url)) { return url; }\n    // Blob URL\n    if (/^blob:.*$/i.test(url)) { return url; }\n    // Relative URL\n    return path + url;\n}\n", "// Based on THREE.LoaderUtils\n// https://github.com/mrdoob/three.js/blob/master/src/loaders/LoaderUtils.js\n\ndeclare var TextDecoder: any;\n\nexport class LoaderUtils {\n    static decodeText(array: ArrayLike<number>): string {\n        /* istanbul ignore next */\n        if (typeof TextDecoder !== 'undefined') {\n            return new TextDecoder().decode(array);\n        }\n\n        // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n        // throws a \"maximum call stack size exceeded\" error for large arrays.\n        let s = '';\n        for (const c of array as Array<number>) {\n            // Implicitly assumes little-endian.\n            s += String.fromCharCode(c);\n        }\n\n        // Merges multi-byte utf-8 characters.\n        return decodeURIComponent(escape(s));\n    }\n\n    static extractUrlBase(url: string) {\n        const parts = url.split('/');\n        if (parts.length === 1) { return './'; }\n        parts.pop();\n        return parts.join('/') + '/';\n    }\n}\n", "// Adapted from THEE.FileLoader\n// https://github.com/mrdoob/three.js/blob/master/src/loaders/FileLoader.js\n\nimport { LoadingManager } from './loadingmanager';\n\nexport type ProgressCallback = (xhr: XMLHttpRequest) => void;\nexport type XMLHttpRequestResponse = any;\n\nexport class FileLoader {\n    manager: LoadingManager;\n    path: string | undefined;\n    responseType: XMLHttpRequestResponseType;\n    withCredentials: boolean;\n    mimeType: string;\n    requestHeaders: { [k: string]: string } ;\n\n    private runningRequests: { [url: string]: Promise<XMLHttpRequestResponse>} = {};\n\n    constructor(manager: LoadingManager) {\n        this.manager = manager;\n    }\n    load(url: string, onProgress?: ProgressCallback): Promise<XMLHttpRequestResponse> {\n        if (this.path !== undefined) { url = this.path + url; }\n        url = this.manager.resolveURL(url);\n\n        if (this.runningRequests[url]) {\n            return this.runningRequests[url];\n        }\n\n        const promise = new Promise((resolve, reject) => {\n            // TODO!!: Check for data: URI\n            // (-> Safari can not handle Data URIs through XMLHttpRequest so process manually)\n\n            // NOTE: Not using `fetch` because it doesn't support progress reporting\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', url, true);\n            const self = this;\n            xhr.onload = function(event: ProgressEvent) {\n                const response = this.response;\n\n                /* istanbul ignore if */\n                if (this.status === 0) {\n                    // Some browsers return HTTP Status 0 when using non-http protocol\n                    // e.g. 'file://' or 'data://'. Handle as success.\n                    console.warn('FileLoader: HTTP Status 0 received.');\n                    resolve(response);\n                    self.manager.itemEnd(url);\n                } else if (this.status === 200) {\n                    resolve(response);\n                    self.manager.itemEnd(url);\n                } else {\n                    reject({\n                        url,\n                        status: this.status,\n                        statusText: xhr.statusText,\n                    });\n\n                    self.manager.itemEnd(url);\n                    self.manager.itemError(url);\n                }\n\n                delete self.runningRequests[url];\n            };\n\n            xhr.onprogress = (xhr: any) => {\n                if (onProgress) {\n                    onProgress(xhr);\n                }\n            };\n\n            /* istanbul ignore next */\n            xhr.onerror = function(event: ErrorEvent) {\n                reject({\n                    url,\n                    status: this.status,\n                    statusText: xhr.statusText,\n                });\n                self.manager.itemEnd(url);\n                self.manager.itemError(url);\n\n                delete self.runningRequests[url];\n            };\n\n            if (this.responseType) { xhr.responseType = this.responseType; }\n            if (this.withCredentials) { xhr.withCredentials = this.withCredentials; }\n            if (this.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n            }\n\n            for (const header in this.requestHeaders) {\n                xhr.setRequestHeader(header, this.requestHeaders[header]);\n            }\n\n            // tslint:disable-next-line:no-null-keyword\n            xhr.send(null);\n            this.manager.itemStart(url);\n        });\n\n        this.runningRequests[url] = promise;\n\n        return promise;\n    }\n\n    setRequestHeader(key: string, value: string) {\n        this.requestHeaders[key] = value;\n        return this;\n    }\n}\n", "import { LoaderUtils } from './loaderutils';\n\nexport const BINARY_HEADER_MAGIC = 'glTF';\nconst BINARY_HEADER_LENGTH = 12;\nconst BINARY_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nexport class GLTFBinaryData {\n    json: string;\n    binaryChunk: Uint8Array;\n    constructor(data: ArrayBuffer) {\n        const headerView = new DataView(data, 0, BINARY_HEADER_LENGTH);\n\n        const header = {\n            magic: LoaderUtils.decodeText(new Uint8Array(data, 0, 4)),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true),\n        };\n\n        if (header.magic !== BINARY_HEADER_MAGIC) {\n            throw new Error('Unsupported glTF-Binary header.');\n        } else if (header.version < 2.0) {\n            throw new Error('Unsupported legacy binary file detected.');\n        }\n\n        const chunkView = new DataView(data, BINARY_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while (chunkIndex < chunkView.byteLength) {\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n\n            if (chunkType === BINARY_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.json = LoaderUtils.decodeText(contentArray);\n\n            } else if (chunkType === BINARY_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_HEADER_LENGTH + chunkIndex;\n                this.binaryChunk = new Uint8Array(data, byteOffset, chunkLength);\n            }\n\n            // Clients must ignore chunks with unknown types.\n\n            chunkIndex += chunkLength;\n        }\n\n        if (this.json === null) {\n            throw new Error('glTF-Binary: JSON content not found.');\n        }\n    }\n}\n", "// Originally derived from THREE.GLTFLoader\n// https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js\n\nimport { FileLoader } from './fileloader';\nimport { BINARY_HEADER_MAGIC, GLTFBinaryData } from './glb-decoder';\nimport { GltfAsset } from './gltf-asset';\nimport { LoaderUtils } from './loaderutils';\nimport { LoadingManager } from './loadingmanager';\n\n// main library exports\nimport * as gltf from './gltf';\nexport {gltf };\nexport * from './gltf-asset';\nexport * from './loadingmanager';\n\n/** Main class of the library */\nexport class GltfLoader {\n    private manager: LoadingManager;\n\n    /**\n     * Pass in a custom `LoadingManager` for progress reporting.\n     */\n    constructor(manager?: LoadingManager) {\n        this.manager = manager || new LoadingManager();\n    }\n\n    /**\n     * Load glTF from a URL. Only the main file is loaded - external buffer and image files\n     * are loaded lazily when needed. To load all, you can use `GltfAsset.preFetchAll()`\n     */\n    async load(url: string, onProgress?: (xhr: XMLHttpRequest) => void): Promise<GltfAsset> {\n        // TODO!!: test data URI here\n        const path = LoaderUtils.extractUrlBase(url);\n        // TODO!: allow changing loader options(headers etc.)?\n        const loader = new FileLoader(this.manager);\n        loader.responseType = 'arraybuffer';\n        const data = await loader.load(url, onProgress);\n        return await this.parse(data, path);\n    }\n\n    /**\n     * Load from `File`s you might get from a file input or via drag-and-drop.\n     * `fileMap` is expected to map from a full file path (including directories if present).\n     * This matches the format provided by [simple-dropzone](https://www.npmjs.com/package/simple-dropzone).\n     * If you don't need support for directories/zip files, you can use `File.name` as the key.\n     *\n     * Note that `preFetchAll` is called on the result GltfAsset before returning it so that\n     * the uploaded files can be garbage-collected immediately.\n     */\n    /* istanbul ignore next: relies too much on browser APIs; covered by drag-and-drop example */\n    async loadFromFiles(fileMap: Map<string, File>): Promise<GltfAsset> {\n        // code derived from three-gltf-viewer\n        let rootFile;\n        let rootPath: string;\n        for (const [path, file] of fileMap) {\n            if (file.name.match(/\\.(gltf|glb)$/)) {\n                rootFile = file;\n                rootPath = path.replace(file.name, '');\n            }\n        }\n\n        if (!rootFile) {\n          throw new Error('No .gltf or .glb asset found.');\n        }\n\n        const fileURL = typeof rootFile === 'string'\n            ? rootFile\n            : URL.createObjectURL(rootFile);\n\n        // Intercept and override relative URLs.\n        const baseURL = LoaderUtils.extractUrlBase(fileURL); // TODO!!: does this make sense here?\n        const blobURLs: string[] = [];\n        this.manager.urlModifier = (url: string) => {\n            const normalizedURL = rootPath + url\n            .replace(baseURL, '')\n            .replace(/^(\\.?\\/)/, '');\n\n            if (fileMap.has(normalizedURL)) {\n                const blob = fileMap.get(normalizedURL);\n                const blobURL = URL.createObjectURL(blob);\n                blobURLs.push(blobURL);\n                return blobURL;\n            }\n\n            return url;\n        };\n\n        const asset = await this.load(fileURL);\n        await asset.preFetchAll(); // fetch all so the object urls can be released below\n\n        URL.revokeObjectURL(fileURL);\n        blobURLs.forEach(URL.revokeObjectURL);\n\n        return asset;\n    }\n\n    private async parse(data: ArrayBuffer, path: string): Promise<GltfAsset> {\n        let content: string;\n        // tslint:disable-next-line:no-unnecessary-initializer\n        let glbData: GLTFBinaryData | undefined = undefined;\n        if (typeof data === 'string') {\n            content = data;\n        } else {\n            const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n            if (magic === BINARY_HEADER_MAGIC) {\n                glbData = new GLTFBinaryData(data);\n                content = glbData.json;\n            } else {\n                content = LoaderUtils.decodeText(new Uint8Array(data));\n            }\n        }\n\n        const json = JSON.parse(content);\n\n        if (json.asset === undefined || json.asset.version[ 0 ] < 2) {\n            throw new Error('Unsupported asset. glTF versions >=2.0 are supported.');\n        }\n\n        return new GltfAsset(json, path, glbData, this.manager);\n    }\n}\n", "export default require(\"./node_modules/gltf-loader-ts/lib/gltf-loader.js\");"],
  "mappings": "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",
  "names": []
}
