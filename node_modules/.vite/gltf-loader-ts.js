var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/gltf-loader-ts/lib/gltf-loader.js
var require_gltf_loader = __commonJS({
  "node_modules/gltf-loader-ts/lib/gltf-loader.js"(exports, module) {
    module.exports = function(e) {
      var t = {};
      function r(i) {
        if (t[i])
          return t[i].exports;
        var s = t[i] = { i, l: false, exports: {} };
        return e[i].call(s.exports, s, s.exports, r), s.l = true, s.exports;
      }
      return r.m = e, r.c = t, r.d = function(e2, t2, i) {
        r.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: i });
      }, r.r = function(e2) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, r.t = function(e2, t2) {
        if (1 & t2 && (e2 = r(e2)), 8 & t2)
          return e2;
        if (4 & t2 && typeof e2 == "object" && e2 && e2.__esModule)
          return e2;
        var i = Object.create(null);
        if (r.r(i), Object.defineProperty(i, "default", { enumerable: true, value: e2 }), 2 & t2 && typeof e2 != "string")
          for (var s in e2)
            r.d(i, s, function(t3) {
              return e2[t3];
            }.bind(null, s));
        return i;
      }, r.n = function(e2) {
        var t2 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return r.d(t2, "a", t2), t2;
      }, r.o = function(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }, r.p = "", r(r.s = 7);
    }([function(e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: true });
      t.LoadingManager = class {
        constructor() {
          this.urlModifier = void 0, this.onStart = void 0, this.onProgress = void 0, this.onLoad = void 0, this.onError = void 0, this.isLoading = false, this.itemsLoaded = 0, this.itemsTotal = 0;
        }
        itemStart(e2) {
          this.itemsTotal++, !this.isLoading && this.onStart && this.onStart(e2, this.itemsLoaded, this.itemsTotal), this.isLoading = true;
        }
        itemEnd(e2) {
          this.itemsLoaded++, this.onProgress && this.onProgress(e2, this.itemsLoaded, this.itemsTotal), this.itemsLoaded === this.itemsTotal && (this.isLoading = false, this.onLoad && this.onLoad());
        }
        itemError(e2) {
          this.onError && this.onError(e2);
        }
        resolveURL(e2) {
          return this.urlModifier ? this.urlModifier(e2) : e2;
        }
      };
    }, function(e, t, r) {
      "use strict";
      var i = this && this.__awaiter || function(e2, t2, r2, i2) {
        return new (r2 || (r2 = Promise))(function(s2, n2) {
          function o2(e3) {
            try {
              u2(i2.next(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function a2(e3) {
            try {
              u2(i2.throw(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function u2(e3) {
            e3.done ? s2(e3.value) : new r2(function(t3) {
              t3(e3.value);
            }).then(o2, a2);
          }
          u2((i2 = i2.apply(e2, t2 || [])).next());
        });
      };
      Object.defineProperty(t, "__esModule", { value: true });
      const s = r(3), n = r(0);
      t.GLTF_COMPONENT_TYPE_ARRAYS = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, t.GLTF_ELEMENTS_PER_TYPE = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      t.GltfAsset = class {
        constructor(e2, t2, r2, i2 = new n.LoadingManager()) {
          this.gltf = e2, this.glbData = r2, this.bufferData = new o(this, t2, i2), this.imageData = new a(this, t2, i2);
        }
        bufferViewData(e2) {
          return i(this, void 0, void 0, function* () {
            if (!this.gltf.bufferViews)
              throw new Error("No buffer views found.");
            const t2 = this.gltf.bufferViews[e2], r2 = yield this.bufferData.get(t2.buffer), i2 = t2.byteLength || 0, s2 = t2.byteOffset || 0, n2 = r2.buffer, o2 = r2.byteOffset;
            return new Uint8Array(n2, o2 + s2, i2);
          });
        }
        accessorData(e2) {
          return i(this, void 0, void 0, function* () {
            if (!this.gltf.accessors)
              throw new Error("No accessors views found.");
            const r2 = this.gltf.accessors[e2], i2 = t.GLTF_ELEMENTS_PER_TYPE[r2.type];
            let s2;
            if (r2.bufferView !== void 0)
              s2 = yield this.bufferViewData(r2.bufferView);
            else {
              const e3 = t.GLTF_COMPONENT_TYPE_ARRAYS[r2.componentType].BYTES_PER_ELEMENT * i2 * r2.count;
              s2 = new Uint8Array(e3);
            }
            if (r2.sparse) {
              const { count: e3, indices: n2, values: o2 } = r2.sparse;
              let a2 = t.GLTF_COMPONENT_TYPE_ARRAYS[n2.componentType], u2 = yield this.bufferViewData(n2.bufferView);
              const f = new a2(u2.buffer, u2.byteOffset + (n2.byteOffset || 0), e3);
              a2 = t.GLTF_COMPONENT_TYPE_ARRAYS[r2.componentType], u2 = yield this.bufferViewData(o2.bufferView);
              const c = new a2((yield this.bufferViewData(o2.bufferView)).buffer, u2.byteOffset + (o2.byteOffset || 0), e3 * i2);
              r2.bufferView && (s2 = new Uint8Array(s2));
              const h = new t.GLTF_COMPONENT_TYPE_ARRAYS[r2.componentType](s2.buffer);
              for (let t2 = 0; t2 < e3; t2++)
                for (let e4 = 0; e4 < i2; e4++)
                  h[i2 * f[t2] + e4] = c[i2 * t2 + e4];
            }
            return s2;
          });
        }
        preFetchAll() {
          return i(this, void 0, void 0, function* () {
            return Promise.all([this.bufferData.preFetchAll(), this.imageData.preFetchAll()]);
          });
        }
      };
      class o {
        constructor(e2, t2, r2) {
          this.bufferCache = [], this.asset = e2, this.baseUri = t2, this.manager = r2, this.loader = new s.FileLoader(r2), this.loader.responseType = "arraybuffer";
        }
        get(e2) {
          return i(this, void 0, void 0, function* () {
            if (this.bufferCache[e2] !== void 0)
              return this.bufferCache[e2];
            const t2 = this.asset.gltf;
            if (!t2.buffers)
              throw new Error("No buffers found.");
            const r2 = t2.buffers[e2];
            if (r2.uri === void 0) {
              if (e2 !== 0)
                throw new Error("GLB container is required to be the first buffer");
              if (this.asset.glbData === void 0)
                throw new Error("invalid gltf: buffer has no uri nor is there a GLB buffer");
              return this.asset.glbData.binaryChunk;
            }
            const i2 = u(r2.uri, this.baseUri), s2 = yield this.loader.load(i2), n2 = new Uint8Array(s2);
            return this.bufferCache[e2] = n2, n2;
          });
        }
        preFetchAll() {
          return i(this, void 0, void 0, function* () {
            const e2 = this.asset.gltf.buffers;
            return e2 ? Promise.all(e2.map((e3, t2) => this.get(t2))) : [];
          });
        }
      }
      t.BufferData = o;
      class a {
        constructor(e2, t2, r2) {
          this.crossOrigin = "anonymous", this.imageCache = [], this.asset = e2, this.baseUri = t2, this.manager = r2;
        }
        get(e2) {
          return i(this, void 0, void 0, function* () {
            if (this.imageCache[e2] !== void 0)
              return this.imageCache[e2];
            const t2 = this.asset.gltf;
            if (!t2.images)
              throw new Error("No images found.");
            const r2 = t2.images[e2];
            let i2, s2 = false;
            if (r2.bufferView !== void 0) {
              const e3 = yield this.asset.bufferViewData(r2.bufferView);
              s2 = true;
              const t3 = new Blob([e3], { type: r2.mimeType });
              i2 = URL.createObjectURL(t3);
            } else {
              if (r2.uri === void 0)
                throw new Error("Invalid glTF: image must either have a `uri` or a `bufferView`");
              i2 = this.manager.resolveURL(u(r2.uri, this.baseUri));
            }
            const n2 = new Image();
            return n2.crossOrigin = this.crossOrigin, new Promise((t3, r3) => {
              n2.onerror = () => {
                r3(`Failed to load ${i2}`), this.manager.itemEnd(i2), this.manager.itemError(i2);
              }, n2.onload = () => {
                s2 && URL.revokeObjectURL(i2), this.imageCache[e2] = n2, t3(n2), this.manager.itemEnd(i2);
              }, n2.src = i2, this.manager.itemStart(i2);
            });
          });
        }
        preFetchAll() {
          return i(this, void 0, void 0, function* () {
            const e2 = this.asset.gltf.images;
            return e2 ? Promise.all(e2.map((e3, t2) => this.get(t2))) : [];
          });
        }
      }
      function u(e2, t2) {
        return typeof e2 != "string" || e2 === "" ? "" : /^(https?:)?\/\//i.test(e2) ? e2 : /^data:.*,.*$/i.test(e2) ? e2 : /^blob:.*$/i.test(e2) ? e2 : t2 + e2;
      }
      t.ImageData = a, t.resolveURL = u;
    }, function(e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: true });
      t.LoaderUtils = class {
        static decodeText(e2) {
          if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e2);
          let t2 = "";
          for (const r2 of e2)
            t2 += String.fromCharCode(r2);
          return decodeURIComponent(escape(t2));
        }
        static extractUrlBase(e2) {
          const t2 = e2.split("/");
          return t2.length === 1 ? "./" : (t2.pop(), t2.join("/") + "/");
        }
      };
    }, function(e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: true });
      t.FileLoader = class {
        constructor(e2) {
          this.runningRequests = {}, this.manager = e2;
        }
        load(e2, t2) {
          if (this.path !== void 0 && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2), this.runningRequests[e2])
            return this.runningRequests[e2];
          const r2 = new Promise((r3, i) => {
            const s = new XMLHttpRequest();
            s.open("GET", e2, true);
            const n = this;
            s.onload = function(t3) {
              const o = this.response;
              this.status === 0 ? (console.warn("FileLoader: HTTP Status 0 received."), r3(o), n.manager.itemEnd(e2)) : this.status === 200 ? (r3(o), n.manager.itemEnd(e2)) : (i({ url: e2, status: this.status, statusText: s.statusText }), n.manager.itemEnd(e2), n.manager.itemError(e2)), delete n.runningRequests[e2];
            }, s.onprogress = (e3) => {
              t2 && t2(e3);
            }, s.onerror = function(t3) {
              i({ url: e2, status: this.status, statusText: s.statusText }), n.manager.itemEnd(e2), n.manager.itemError(e2), delete n.runningRequests[e2];
            }, this.responseType && (s.responseType = this.responseType), this.withCredentials && (s.withCredentials = this.withCredentials), this.mimeType && s.overrideMimeType && s.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
            for (const e3 in this.requestHeaders)
              s.setRequestHeader(e3, this.requestHeaders[e3]);
            s.send(null), this.manager.itemStart(e2);
          });
          return this.runningRequests[e2] = r2, r2;
        }
        setRequestHeader(e2, t2) {
          return this.requestHeaders[e2] = t2, this;
        }
      };
    }, function(e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: true });
    }, function(e, t, r) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: true });
      const i = r(2);
      t.BINARY_HEADER_MAGIC = "glTF";
      const s = 12, n = { JSON: 1313821514, BIN: 5130562 };
      t.GLTFBinaryData = class {
        constructor(e2) {
          const r2 = new DataView(e2, 0, s), o = i.LoaderUtils.decodeText(new Uint8Array(e2, 0, 4)), a = r2.getUint32(4, true);
          if (r2.getUint32(8, true), o !== t.BINARY_HEADER_MAGIC)
            throw new Error("Unsupported glTF-Binary header.");
          if (a < 2)
            throw new Error("Unsupported legacy binary file detected.");
          const u = new DataView(e2, s);
          let f = 0;
          for (; f < u.byteLength; ) {
            const t2 = u.getUint32(f, true);
            f += 4;
            const r3 = u.getUint32(f, true);
            if (f += 4, r3 === n.JSON) {
              const r4 = new Uint8Array(e2, s + f, t2);
              this.json = i.LoaderUtils.decodeText(r4);
            } else if (r3 === n.BIN) {
              const r4 = s + f;
              this.binaryChunk = new Uint8Array(e2, r4, t2);
            }
            f += t2;
          }
          if (this.json === null)
            throw new Error("glTF-Binary: JSON content not found.");
        }
      };
    }, function(e, t, r) {
      "use strict";
      var i = this && this.__awaiter || function(e2, t2, r2, i2) {
        return new (r2 || (r2 = Promise))(function(s2, n2) {
          function o2(e3) {
            try {
              u2(i2.next(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function a2(e3) {
            try {
              u2(i2.throw(e3));
            } catch (e4) {
              n2(e4);
            }
          }
          function u2(e3) {
            e3.done ? s2(e3.value) : new r2(function(t3) {
              t3(e3.value);
            }).then(o2, a2);
          }
          u2((i2 = i2.apply(e2, t2 || [])).next());
        });
      };
      function s(e2) {
        for (var r2 in e2)
          t.hasOwnProperty(r2) || (t[r2] = e2[r2]);
      }
      Object.defineProperty(t, "__esModule", { value: true });
      const n = r(3), o = r(5), a = r(1), u = r(2), f = r(0), c = r(4);
      t.gltf = c, s(r(1)), s(r(0));
      t.GltfLoader = class {
        constructor(e2) {
          this.manager = e2 || new f.LoadingManager();
        }
        load(e2, t2) {
          return i(this, void 0, void 0, function* () {
            const r2 = u.LoaderUtils.extractUrlBase(e2), i2 = new n.FileLoader(this.manager);
            i2.responseType = "arraybuffer";
            const s2 = yield i2.load(e2, t2);
            return yield this.parse(s2, r2);
          });
        }
        loadFromFiles(e2) {
          return i(this, void 0, void 0, function* () {
            let t2, r2;
            for (const [i3, s3] of e2)
              s3.name.match(/\.(gltf|glb)$/) && (t2 = s3, r2 = i3.replace(s3.name, ""));
            if (!t2)
              throw new Error("No .gltf or .glb asset found.");
            const i2 = typeof t2 == "string" ? t2 : URL.createObjectURL(t2), s2 = u.LoaderUtils.extractUrlBase(i2), n2 = [];
            this.manager.urlModifier = (t3) => {
              const i3 = r2 + t3.replace(s2, "").replace(/^(\.?\/)/, "");
              if (e2.has(i3)) {
                const t4 = e2.get(i3), r3 = URL.createObjectURL(t4);
                return n2.push(r3), r3;
              }
              return t3;
            };
            const o2 = yield this.load(i2);
            return yield o2.preFetchAll(), URL.revokeObjectURL(i2), n2.forEach(URL.revokeObjectURL), o2;
          });
        }
        parse(e2, t2) {
          return i(this, void 0, void 0, function* () {
            let r2, i2 = void 0;
            r2 = typeof e2 == "string" ? e2 : u.LoaderUtils.decodeText(new Uint8Array(e2, 0, 4)) === o.BINARY_HEADER_MAGIC ? (i2 = new o.GLTFBinaryData(e2)).json : u.LoaderUtils.decodeText(new Uint8Array(e2));
            const s2 = JSON.parse(r2);
            if (s2.asset === void 0 || s2.asset.version[0] < 2)
              throw new Error("Unsupported asset. glTF versions >=2.0 are supported.");
            return new a.GltfAsset(s2, t2, i2, this.manager);
          });
        }
      };
    }, function(e, t, r) {
      e.exports = r(6);
    }]);
  }
});

// dep:gltf-loader-ts
var gltf_loader_ts_default = require_gltf_loader();
export {
  gltf_loader_ts_default as default
};
//# sourceMappingURL=gltf-loader-ts.js.map
